<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>F1 Grid Replay</title>
    <style>
        body { font-family: sans-serif; text-align: center; background-color: #111; color: white; padding: 20px;}
        canvas { background-color: #222; border: 2px solid #444; border-radius: 8px; box-shadow: 0px 4px 15px rgba(0,0,0,0.5); }
        button { padding: 12px 24px; font-size: 16px; margin-bottom: 20px; cursor: pointer; background-color: #e10600; color: white; border: none; border-radius: 4px; font-weight: bold;}
        button:disabled { background-color: #555; cursor: not-allowed; }
    </style>
</head>
<body>

    <h2>2023 Monaco GP - Full Grid</h2>
    <button id="startRace">Start Race Simulation</button>
    <br>
    <canvas id="trackCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('trackCanvas');
        const ctx = canvas.getContext('2d');
        
        let driversData = {}; // Will hold { 14: [...], 1: [...], 16: [...] }
        let earliestTime = Infinity;
        let latestTime = -Infinity;
        
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let scale = 1;
        let offsetX = 0, offsetY = 0;

        // 1. Fetch the massive dataset
        async function fetchRaceData() {
            try {
                // Pointing to our new "all drivers" URL route
                const response = await fetch('/racer/map/api/locations/all/9094/');
                const data = await response.json();
                
                // Filter out bad GPS points globally
                let rawData = data.locations.filter(point => 
                    point.x != null && point.y != null && 
                    point.x !== 0 && point.y !== 0
                );

                // Group the data by Driver Number and find the min/max X and Y bounds
                rawData.forEach(point => {
                    if (!driversData[point.driver_number]) {
                        driversData[point.driver_number] = [];
                    }
                    driversData[point.driver_number].push(point);

                    // Track bounds for scaling
                    if (point.x < minX) minX = point.x;
                    if (point.x > maxX) maxX = point.x;
                    if (point.y < minY) minY = point.y;
                    if (point.y > maxY) maxY = point.y;

                    // Track global time
                    let time = new Date(point.date).getTime();
                    if (time < earliestTime) earliestTime = time;
                    if (time > latestTime) latestTime = time;
                });

                // Ensure every driver's array is perfectly sorted by time
                for (let driver in driversData) {
                    driversData[driver].sort((a, b) => new Date(a.date) - new Date(b.date));
                }

            } catch (error) {
                console.error("Error fetching data:", error);
                alert("Make sure you ran the Python fetch script first to get all drivers!");
            }
        }

        // 2. Calculate Scaling
        function calculateScale() {
            const trackWidth = maxX - minX;
            const trackHeight = maxY - minY;
            
            const padding = 0.9; 
            const scaleX = canvas.width / trackWidth;
            const scaleY = canvas.height / trackHeight;
            
            scale = Math.min(scaleX, scaleY) * padding;
            offsetX = (canvas.width - (trackWidth * scale)) / 2;
            offsetY = (canvas.height - (trackHeight * scale)) / 2;
        }

        function getCanvasCoords(rawX, rawY) {
            return {
                x: ((rawX - minX) * scale) + offsetX,
                y: ((maxY - rawY) * scale) + offsetY 
            };
        }

        // 3. The Global Animation Loop
        function simulateRace() {
            // Pick ONE driver (e.g., driver 14) to draw a single clean track outline
            const trackPath = new Path2D();
            const outlineDriver = driversData['14'] || driversData[Object.keys(driversData)[0]];
            
            outlineDriver.forEach((point, index) => {
                const coords = getCanvasCoords(point.x, point.y);
                if (index === 0) trackPath.moveTo(coords.x, coords.y);
                else trackPath.lineTo(coords.x, coords.y);
            });

            // Master Simulation Variables
            let currentTime = earliestTime; 
            let playbackSpeed = 20; // <--- Change this to speed up or slow down the race!
            let lastFrameTime = performance.now();
            
            // Pointers to keep track of where each driver is in their own array
            let pointers = {};
            for (let driver in driversData) {
                pointers[driver] = 0;
            }

            // The Render Frame
            function render(now) {
                if (currentTime > latestTime) {
                    document.getElementById('startRace').innerText = "Race Finished";
                    return;
                }

                // Calculate real-world time passed since last frame, apply multiplier
                let deltaTime = now - lastFrameTime;
                lastFrameTime = now;
                currentTime += deltaTime * playbackSpeed;

                // 1. Wipe and redraw track
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.stroke(trackPath);

                // 2. Draw all 20 drivers at their current time
                for (let driver in driversData) {
                    let pts = driversData[driver];
                    let p = pointers[driver];

                    // Advance this driver's timeline pointer until it catches up with the Global Clock
                    while (p < pts.length - 1 && new Date(pts[p+1].date).getTime() <= currentTime) {
                        p++;
                    }
                    pointers[driver] = p; // Save their current location index

                    let currentPoint = pts[p];
                    
                    if (currentPoint) {
                        const coords = getCanvasCoords(currentPoint.x, currentPoint.y);
                        
                        // Draw Dot
                        ctx.fillStyle = '#00ff00'; 
                        ctx.beginPath();
                        ctx.arc(coords.x, coords.y, 4, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw Driver Number right above the dot!
                        ctx.fillStyle = "white";
                        ctx.font = "12px Arial";
                        ctx.fillText(driver, coords.x + 6, coords.y - 6);
                    }
                }

                requestAnimationFrame(render); // Ask the browser to draw the next frame
            }

            requestAnimationFrame(render); // Kick off the loop
        }

        // 4. Hook it to the button
        document.getElementById('startRace').addEventListener('click', async () => {
            const btn = document.getElementById('startRace');
            btn.disabled = true;
            btn.innerText = "Loading data... (This might take a few seconds)";
            
            await fetchRaceData();
            calculateScale();
            
            btn.innerText = `Race in Progress (${Object.keys(driversData).length} Drivers)`;
            simulateRace();
        });
    </script>
</body>
</html>